<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>{{SITE_TITLE}}</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="{{SITE_DESCRIPTION}}" />
  <link rel="icon" href="{{SITE_ICON}}" type="image/png" />
  <meta property="og:title" content="{{SITE_TITLE}}" />
  <meta property="og:description" content="{{SITE_DESCRIPTION}}" />
  <meta property="og:type" content="website" />
  {{OG_IMAGE_TAG}}
  <meta property="og:url" content="{{SITE_URL}}" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="{{SITE_TITLE}}" />
  <meta name="twitter:description" content="{{SITE_DESCRIPTION}}" />
  {{TWITTER_IMAGE_TAG}}
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; }
    .hud {
      position: absolute;
      top: 10px; left: 10px;
      background: rgba(0,0,0,.65);
      color: #fff;
      padding: 10px 12px;
      border-radius: 10px;
      font-family: ui-sans-serif, system-ui, sans-serif;
      z-index: 999;
      max-width: 340px;
    }
    .hud-header { display: flex; align-items: center; justify-content: space-between; gap: 10px; }
    .hud-brand { display: flex; align-items: center; gap: 8px; }
    .hud-logo { width: 28px; height: 28px; border-radius: 6px; object-fit: contain; background: rgba(255,255,255,.08); padding: 2px; }
    .hud-github {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 30px;
      height: 30px;
      border-radius: 8px;
      background: rgba(255,255,255,.12);
      border: 1px solid rgba(255,255,255,.2);
      color: #fff;
      text-decoration: none;
      transition: background .2s ease, border-color .2s ease;
    }
    .hud-github:hover {
      background: rgba(255,255,255,.22);
      border-color: rgba(255,255,255,.4);
    }
    .hud-github svg { width: 16px; height: 16px; fill: currentColor; }
    .small { opacity: .85; font-size: 12px; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; background: rgba(255,255,255,.12); margin-right:6px; }
    .legend { margin-top: 8px; display: grid; gap: 6px; }
    .legend-item { display: flex; align-items: center; gap: 8px; font-size: 12px; opacity: 0.9; }
    .legend-line { width: 30px; height: 0; border-top: 4px solid; display: inline-block; }
    .legend-trace { border-color: #ff7a1a; border-top-style: dashed; }
    .legend-message { border-color: #2b8cff; border-top-style: dashed; }
    .legend-advert { border-color: #2ecc71; border-top-style: dotted; }
    .legend-los-clear { border-color: #22c55e; border-top-style: solid; }
    .legend-los-blocked { border-color: #ef4444; border-top-style: dashed; }
    .legend-dot { width: 12px; height: 12px; border-radius: 50%; border: 2px solid; display: inline-block; }
    .legend-repeater { border-color: #1d4ed8; background: #2b8cff; }
    .legend-companion { border-color: #6b21a8; background: #a855f7; }
    .legend-room { border-color: #b45309; background: #f59e0b; }
    .legend-unknown { border-color: #4b5563; background: #d1d5db; }
    .legend-heat { width: 30px; height: 10px; border-radius: 6px; background: linear-gradient(90deg, #fbbf24, #f97316, #ef4444, #b91c1c); border: 1px solid rgba(255,255,255,.25); display: inline-block; }
    .legend-toggle {
      margin-top: 6px;
      font-size: 12px;
      background: rgba(255,255,255,.12);
      color: #fff;
      border: 1px solid rgba(255,255,255,.2);
      border-radius: 8px;
      padding: 4px 8px;
      cursor: pointer;
    }
    .legend-collapsed .legend { display: none; }
    .map-toggle {
      margin-top: 6px;
      font-size: 12px;
      background: rgba(255,255,255,.12);
      color: #fff;
      border: 1px solid rgba(255,255,255,.2);
      border-radius: 8px;
      padding: 4px 8px;
      cursor: pointer;
    }
    .map-toggle.active {
      background: rgba(34,197,94,.35);
      border-color: rgba(34,197,94,.6);
    }
    .node-search {
      margin-top: 6px;
      position: relative;
    }
    .node-search-input {
      width: 100%;
      font-size: 12px;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.2);
      background: rgba(15,23,42,.6);
      color: #fff;
      outline: none;
    }
    .node-search-input::placeholder { color: rgba(255,255,255,.65); }
    .node-search-results {
      position: absolute;
      left: 0;
      right: 0;
      top: calc(100% + 4px);
      background: rgba(15,23,42,.92);
      border: 1px solid rgba(255,255,255,.2);
      border-radius: 8px;
      overflow: hidden;
      z-index: 1000;
      max-height: 200px;
      overflow-y: auto;
    }
    .node-search-item {
      padding: 6px 8px;
      font-size: 12px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }
    .node-search-item:hover { background: rgba(255,255,255,.12); }
    .node-search-id { opacity: 0.7; }
    .node-label {
      background: rgba(15,23,42,.8);
      color: #fff;
      border: 1px solid rgba(255,255,255,.25);
      border-radius: 8px;
      padding: 2px 6px;
      font-size: 11px;
      white-space: nowrap;
    }
    .leaflet-popup-content { max-width: 260px; overflow-wrap: anywhere; word-break: break-word; }
    .popup-title { display: block; font-weight: 600; }
    .popup-id { display: block; opacity: 0.85; }
    .popup-topic { display: inline-block; overflow-wrap: anywhere; word-break: break-word; }
    .los-profile {
      margin-top: 6px;
      padding: 6px 8px;
      border-radius: 10px;
      background: rgba(15,23,42,.35);
      border: 1px solid rgba(255,255,255,.15);
      position: relative;
    }
    .los-profile-title { margin-bottom: 4px; }
    .los-profile svg { width: 100%; height: 86px; display: block; }
    .los-profile-terrain { fill: none; stroke: rgba(226,232,240,.85); stroke-width: 2; }
    .los-profile-los { fill: none; stroke-width: 2; }
    .los-profile-tooltip {
      position: absolute;
      top: 6px;
      left: 6px;
      background: rgba(15,23,42,.92);
      border: 1px solid rgba(255,255,255,.2);
      border-radius: 8px;
      padding: 4px 6px;
      font-size: 11px;
      color: #fff;
      pointer-events: none;
      white-space: nowrap;
      transform: translate(-50%, -120%);
    }
    .trail-animated {
      stroke-dasharray: 6 10;
      animation: trail-dash 6s linear infinite;
    }
    @keyframes trail-dash {
      to { stroke-dashoffset: -120; }
    }
    .route-animated {
      stroke-dasharray: 12 18;
      animation: route-dash 8s linear infinite;
      stroke-linecap: butt;
      stroke-linejoin: miter;
    }
    @keyframes route-dash {
      to { stroke-dashoffset: -200; }
    }
  </style>
</head>
<body>
  <div class="hud">
    <div class="hud-header">
      <div class="hud-brand">
        <img class="hud-logo" src="/static/logo.png" alt="Greater Boston Mesh" />
        <div><span class="pill">Live</span> {{SITE_TITLE}}</div>
      </div>
      <a class="hud-github" href="https://github.com/yellowcooln/meshcore-mqtt-live-map/" target="_blank" rel="noopener" aria-label="GitHub repository">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M12 2C6.48 2 2 6.58 2 12.26c0 4.5 2.87 8.32 6.84 9.67.5.1.68-.23.68-.5v-1.77c-2.78.62-3.37-1.38-3.37-1.38-.46-1.2-1.12-1.52-1.12-1.52-.9-.64.07-.63.07-.63 1 .07 1.53 1.07 1.53 1.07.9 1.6 2.36 1.14 2.94.87.1-.66.35-1.14.63-1.4-2.22-.27-4.56-1.14-4.56-5.08 0-1.12.39-2.04 1.02-2.76-.1-.27-.45-1.37.1-2.86 0 0 .83-.27 2.72 1.05a9.2 9.2 0 0 1 2.48-.35c.84 0 1.68.12 2.48.35 1.88-1.32 2.7-1.05 2.7-1.05.56 1.5.21 2.6.11 2.86.64.72 1.02 1.64 1.02 2.76 0 3.95-2.34 4.8-4.57 5.07.36.33.68.97.68 1.96v2.9c0 .28.18.6.69.5A10.03 10.03 0 0 0 22 12.26C22 6.58 17.52 2 12 2z"/>
        </svg>
      </a>
    </div>
    <div class="small">Markers update in real time. Trails show last ~50 points.</div>
    <div class="small">{{SITE_FEED_NOTE}}</div>
    <div class="small" id="stats"></div>
    <div class="small" id="los-status"></div>
    <div class="node-search">
      <input class="node-search-input" id="node-search" type="text" placeholder="Search nodes by name or key..." autocomplete="off" />
      <div class="node-search-results" id="node-search-results" hidden></div>
    </div>
    <div class="los-profile" id="los-profile" hidden>
      <div class="small los-profile-title">Elevation profile</div>
      <svg id="los-profile-svg" viewBox="0 0 300 90" preserveAspectRatio="none"></svg>
      <div class="los-profile-tooltip" id="los-profile-tooltip" hidden></div>
    </div>
    <button class="legend-toggle" id="legend-toggle" type="button">Hide legend</button>
    <button class="map-toggle" id="map-toggle" type="button">Dark map</button>
    <button class="map-toggle" id="topo-toggle" type="button">Topo map</button>
    <button class="map-toggle" id="los-toggle" type="button">LOS tool</button>
    <button class="map-toggle" id="labels-toggle" type="button">Labels Off</button>
    <div class="legend">
      <div class="legend-item"><span class="legend-line legend-trace"></span> Trace/path</div>
      <div class="legend-item"><span class="legend-line legend-message"></span> Message</div>
      <div class="legend-item"><span class="legend-line legend-advert"></span> Advert</div>
      <div class="legend-item"><span class="legend-line legend-los-clear"></span> LOS clear</div>
      <div class="legend-item"><span class="legend-line legend-los-blocked"></span> LOS blocked</div>
      <div class="legend-item"><span class="legend-heat"></span> Heat (last 10 min)</div>
      <div class="legend-item"><span class="legend-dot legend-repeater"></span> Repeater</div>
      <div class="legend-item"><span class="legend-dot legend-companion"></span> Companion</div>
      <div class="legend-item"><span class="legend-dot legend-room"></span> Room server</div>
      <div class="legend-item"><span class="legend-dot legend-unknown"></span> Unknown</div>
    </div>
  </div>
  <div id="map"></div>

  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>
  <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>

  <script>
    const map = L.map('map', { zoomControl: false }).setView([{{MAP_START_LAT}}, {{MAP_START_LON}}], {{MAP_START_ZOOM}});
    L.control.zoom({ position: 'bottomright' }).addTo(map);
    const lightTiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);
    const darkTiles = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors &copy; CARTO'
    });
    const topoTiles = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
      maxZoom: 17,
      attribution: '&copy; OpenStreetMap contributors &copy; OpenTopoMap'
    });
    let baseLayer = 'light';
    const storedLayer = localStorage.getItem('meshmapBaseLayer');
    if (storedLayer === 'dark' || storedLayer === 'topo' || storedLayer === 'light') {
      baseLayer = storedLayer;
    }

    const markers = new Map();   // device_id -> Leaflet marker
    const polylines = new Map(); // device_id -> Leaflet polyline
    const routeLines = new Map(); // route_id -> { line, timeout }
    const routeLayer = L.layerGroup().addTo(map);
    const losElevationUrl = '{{LOS_ELEVATION_URL}}';
    const losSampleMin = Number('{{LOS_SAMPLE_MIN}}') || 10;
    const losSampleMax = Number('{{LOS_SAMPLE_MAX}}') || 80;
    const losSampleStepMeters = Number('{{LOS_SAMPLE_STEP_METERS}}') || 250;
    const losPeaksMax = Number('{{LOS_PEAKS_MAX}}') || 4;
    const heatLayer = L.heatLayer([], {
      radius: 28,
      blur: 22,
      minOpacity: 0.2,
      maxZoom: 16,
      gradient: { 0.2: '#fbbf24', 0.5: '#f97316', 0.8: '#ef4444', 1.0: '#b91c1c' }
    }).addTo(map);
    const heatPoints = [];
    const HEAT_TTL_MS = 10 * 60 * 1000;
    const losLayer = L.layerGroup().addTo(map);
    let losActive = false;
    let losPoints = [];
    let losLine = null;
    let losSuggestion = null;
    let losPeakMarkers = [];
    const losProfile = document.getElementById('los-profile');
    const losProfileSvg = document.getElementById('los-profile-svg');
    const losProfileTooltip = document.getElementById('los-profile-tooltip');
    let losProfileData = [];
    let losProfileMeta = null;
    const deviceData = new Map();
    const searchInput = document.getElementById('node-search');
    const searchResults = document.getElementById('node-search-results');
    let searchMatches = [];
    const storedLabels = localStorage.getItem('meshmapShowLabels');
    let showLabels = storedLabels === 'true';
    if (storedLabels === null) {
      localStorage.setItem('meshmapShowLabels', 'false');
    }

    function resolveRole(d) {
      const role = (d.role || '').toLowerCase();
      if (role.includes('repeater')) return 'repeater';
      if (role.includes('companion')) return 'companion';
      if (role.includes('room')) return 'room';
      return 'unknown';
    }

    function markerStyleForRole(role) {
      if (role === 'repeater') {
        return { color: '#1d4ed8', fillColor: '#2b8cff', fillOpacity: 0.95, radius: 8, weight: 2 };
      }
      if (role === 'companion') {
        return { color: '#6b21a8', fillColor: '#a855f7', fillOpacity: 0.95, radius: 8, weight: 2 };
      }
      if (role === 'room') {
        return { color: '#b45309', fillColor: '#f59e0b', fillOpacity: 0.95, radius: 8, weight: 2 };
      }
      return { color: '#4b5563', fillColor: '#d1d5db', fillOpacity: 0.95, radius: 8, weight: 2 };
    }

    function setStats() {
      document.getElementById('stats').textContent = `${markers.size} active devices • ${routeLines.size} routes`;
    }

    function setLosStatus(text) {
      const el = document.getElementById('los-status');
      if (el) {
        el.textContent = text || '';
      }
    }

    function deviceShortId(d) {
      return d.device_id ? `${d.device_id.slice(0, 8)}…` : '';
    }

    function deviceDisplayName(d) {
      return d.name || deviceShortId(d) || 'Unknown';
    }

    function updateMarkerLabel(m, d) {
      if (!m || !d) return;
      if (!showLabels) {
        if (m.getTooltip()) m.unbindTooltip();
        return;
      }
      const label = deviceDisplayName(d);
      if (!label) return;
      if (m.getTooltip()) {
        m.setTooltipContent(label);
      } else {
        m.bindTooltip(label, {
          permanent: true,
          direction: 'top',
          className: 'node-label',
          offset: [0, -6]
        });
      }
    }

    function renderSearchResults(query) {
      if (!searchResults) return;
      const q = (query || '').trim().toLowerCase();
      searchMatches = [];
      if (!q) {
        searchResults.hidden = true;
        searchResults.innerHTML = '';
        return;
      }
      for (const [id, d] of deviceData.entries()) {
        const name = (d.name || '').toLowerCase();
        if (name.includes(q) || id.toLowerCase().includes(q)) {
          searchMatches.push({ id, d });
        }
      }
      searchMatches = searchMatches.slice(0, 8);
      if (searchMatches.length === 0) {
        searchResults.hidden = true;
        searchResults.innerHTML = '';
        return;
      }
      searchResults.innerHTML = '';
      searchMatches.forEach(({ id, d }) => {
        const item = document.createElement('div');
        item.className = 'node-search-item';
        item.innerHTML = `<span>${deviceDisplayName(d)}</span><span class="node-search-id">${id.slice(0, 8)}…</span>`;
        item.addEventListener('click', () => focusDevice(id));
        searchResults.appendChild(item);
      });
      searchResults.hidden = false;
    }

    function focusDevice(id) {
      const marker = markers.get(id);
      const d = deviceData.get(id);
      if (!marker || !d) return;
      const targetZoom = Math.max(map.getZoom(), 13);
      map.flyTo(marker.getLatLng(), targetZoom, { duration: 0.6 });
      marker.openPopup();
      if (searchInput) searchInput.value = '';
      if (searchResults) {
        searchResults.hidden = true;
        searchResults.innerHTML = '';
      }
    }

    function setLabelsActive(active) {
      showLabels = active;
      localStorage.setItem('meshmapShowLabels', showLabels ? 'true' : 'false');
      markers.forEach((m, id) => {
        const d = deviceData.get(id);
        if (d) updateMarkerLabel(m, d);
      });
      const labelsToggle = document.getElementById('labels-toggle');
      if (labelsToggle) {
        labelsToggle.textContent = showLabels ? 'Labels On' : 'Labels Off';
        labelsToggle.classList.toggle('active', showLabels);
      }
    }

    function clearLosProfile() {
      if (!losProfile || !losProfileSvg) return;
      losProfile.hidden = true;
      losProfileSvg.innerHTML = '';
      if (losProfileTooltip) {
        losProfileTooltip.hidden = true;
        losProfileTooltip.textContent = '';
      }
      losProfileData = [];
      losProfileMeta = null;
    }

    function clearLosPeaks() {
      losPeakMarkers.forEach(marker => {
        losLayer.removeLayer(marker);
      });
      losPeakMarkers = [];
    }

    function clearLos() {
      losPoints = [];
      losLine = null;
      losSuggestion = null;
      losLayer.clearLayers();
      setLosStatus('');
      clearLosProfile();
      clearLosPeaks();
    }

    function setLosActive(active) {
      losActive = active;
      const btn = document.getElementById('los-toggle');
      if (btn) {
        btn.classList.toggle('active', active);
        btn.textContent = active ? 'LOS: click 2 points' : 'LOS tool';
      }
      if (!active) {
        clearLos();
      } else {
        setLosStatus('LOS: select first point (Shift+click nodes too)');
      }
    }

    function renderLosProfile(profile, blocked) {
      if (!losProfile || !losProfileSvg) return;
      if (!Array.isArray(profile) || profile.length < 2) {
        clearLosProfile();
        return;
      }
      const width = 300;
      const height = 90;
      const pad = 6;
      const last = profile[profile.length - 1];
      const totalDistance = Math.max(1, Number(last[0]) || 1);
      let minElev = Infinity;
      let maxElev = -Infinity;
      profile.forEach(item => {
        const terrain = Number(item[1]);
        const los = Number(item[2]);
        if (!Number.isNaN(terrain)) {
          minElev = Math.min(minElev, terrain);
          maxElev = Math.max(maxElev, terrain);
        }
        if (!Number.isNaN(los)) {
          minElev = Math.min(minElev, los);
          maxElev = Math.max(maxElev, los);
        }
      });
      if (!Number.isFinite(minElev) || !Number.isFinite(maxElev) || minElev === maxElev) {
        clearLosProfile();
        return;
      }
      const span = maxElev - minElev;
      const innerWidth = width - pad * 2;
      const innerHeight = height - pad * 2;
      const toX = (d) => pad + (d / totalDistance) * innerWidth;
      const toY = (e) => height - pad - ((e - minElev) / span) * innerHeight;
      const terrainPath = profile.map((item, idx) => {
        const d = Number(item[0]);
        const elev = Number(item[1]);
        return `${idx === 0 ? 'M' : 'L'}${toX(d).toFixed(2)} ${toY(elev).toFixed(2)}`;
      }).join(' ');
      const losPath = profile.map((item, idx) => {
        const d = Number(item[0]);
        const elev = Number(item[2]);
        return `${idx === 0 ? 'M' : 'L'}${toX(d).toFixed(2)} ${toY(elev).toFixed(2)}`;
      }).join(' ');
      const losColor = blocked ? '#ef4444' : '#22c55e';
      losProfileSvg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      losProfileSvg.innerHTML = `
        <path class="los-profile-terrain" d="${terrainPath}"></path>
        <path class="los-profile-los" d="${losPath}" stroke="${losColor}"></path>
        <line id="los-profile-cursor" x1="0" y1="0" x2="0" y2="${height}" stroke="rgba(255,255,255,.35)" stroke-width="1" opacity="0" />
        <circle id="los-profile-point" cx="0" cy="0" r="3" fill="${losColor}" opacity="0" />
      `;
      losProfileData = profile;
      losProfileMeta = {
        width,
        height,
        pad,
        minElev,
        maxElev,
        totalDistance,
        innerWidth,
        innerHeight,
        blocked
      };
      losProfile.hidden = false;
    }

    function formatDistanceMeters(meters) {
      if (meters == null) return '';
      const value = Number(meters);
      if (Number.isNaN(value)) return '';
      return value >= 1000 ? `${(value / 1000).toFixed(2)} km` : `${Math.round(value)} m`;
    }

    function formatElevationMeters(meters) {
      if (meters == null) return '';
      const value = Number(meters);
      if (Number.isNaN(value)) return '';
      return `${value.toFixed(1)} m`;
    }

    function updateLosProfileCursor(distance, terrain, losLineValue) {
      if (!losProfileMeta || !losProfileSvg || !losProfileTooltip) return;
      if (!losProfileData || losProfileData.length < 2) return;
      const total = losProfileMeta.totalDistance;
      const clampedDistance = Math.min(Math.max(distance, 0), total);
      const xSvg = losProfileMeta.pad + (clampedDistance / total) * losProfileMeta.innerWidth;
      const ySvg = losProfileMeta.height - losProfileMeta.pad -
        ((terrain - losProfileMeta.minElev) / (losProfileMeta.maxElev - losProfileMeta.minElev)) * losProfileMeta.innerHeight;
      const cursor = document.getElementById('los-profile-cursor');
      const dot = document.getElementById('los-profile-point');
      if (cursor) {
        cursor.setAttribute('x1', xSvg.toFixed(2));
        cursor.setAttribute('x2', xSvg.toFixed(2));
        cursor.setAttribute('opacity', '1');
      }
      if (dot) {
        dot.setAttribute('cx', xSvg.toFixed(2));
        dot.setAttribute('cy', ySvg.toFixed(2));
        dot.setAttribute('opacity', '1');
      }
      losProfileTooltip.hidden = false;
      losProfileTooltip.textContent = `Distance ${formatDistanceMeters(clampedDistance)} • Terrain ${formatElevationMeters(terrain)} • LOS ${formatElevationMeters(losLineValue)}`;
      losProfileTooltip.style.left = `${xSvg}px`;
      losProfileTooltip.style.top = `${ySvg}px`;
    }

    function updateLosProfileHover(ev) {
      if (!losProfileMeta || !losProfileSvg || !losProfileTooltip) return;
      if (!losProfileData || losProfileData.length < 2) return;
      const rect = losProfileSvg.getBoundingClientRect();
      const x = Math.min(Math.max(ev.clientX - rect.left, losProfileMeta.pad), rect.width - losProfileMeta.pad);
      const ratio = (x - losProfileMeta.pad) / Math.max(1, rect.width - losProfileMeta.pad * 2);
      const idx = Math.min(losProfileData.length - 1, Math.max(0, Math.round(ratio * (losProfileData.length - 1))));
      const point = losProfileData[idx];
      if (!point) return;
      updateLosProfileCursor(point[0], point[1], point[2]);
    }

    function updateLosProfileAtDistance(distanceMeters) {
      if (!losProfileData || losProfileData.length < 2 || !losProfileMeta) return;
      const total = losProfileMeta.totalDistance;
      const clamped = Math.min(Math.max(distanceMeters, 0), total);
      const idx = Math.min(losProfileData.length - 1, Math.max(0, Math.round((clamped / total) * (losProfileData.length - 1))));
      const point = losProfileData[idx];
      if (!point) return;
      updateLosProfileCursor(point[0], point[1], point[2]);
    }

    function clearLosProfileHover() {
      const cursor = document.getElementById('los-profile-cursor');
      const dot = document.getElementById('los-profile-point');
      if (cursor) cursor.setAttribute('opacity', '0');
      if (dot) dot.setAttribute('opacity', '0');
      if (losProfileTooltip) losProfileTooltip.hidden = true;
    }

    function updateLosProfileFromMap(latlng) {
      if (!latlng || losPoints.length < 2) return;
      if (!losProfileMeta || !losProfileData || losProfileData.length < 2) return;
      const start = losPoints[0];
      const end = losPoints[1];
      const dLat = end.lat - start.lat;
      const dLon = end.lng - start.lng;
      const denom = (dLat * dLat) + (dLon * dLon);
      if (denom === 0) return;
      let t = ((latlng.lat - start.lat) * dLat + (latlng.lng - start.lng) * dLon) / denom;
      t = Math.min(Math.max(t, 0), 1);
      const totalDistance = haversineMeters(start.lat, start.lng, end.lat, end.lng);
      updateLosProfileAtDistance(totalDistance * t);
    }

    function renderLosPeaks(peaks) {
      clearLosPeaks();
      if (!Array.isArray(peaks) || peaks.length === 0) return;
      peaks.forEach((peak, idx) => {
        const lat = Number(peak.lat);
        const lon = Number(peak.lon);
        if (Number.isNaN(lat) || Number.isNaN(lon)) return;
        const index = peak.index || (idx + 1);
        const distance = formatDistanceMeters(peak.distance_m);
        const elev = peak.elevation_m != null ? `${peak.elevation_m} m` : '';
        const coord = `${lat.toFixed(5)}, ${lon.toFixed(5)}`;
        const tooltip = `Peak ${index}${distance ? ` • ${distance}` : ''}<br/>${coord}${elev ? `<br/>${elev}` : ''}`;
        const marker = L.circleMarker([lat, lon], {
          radius: 4,
          color: '#f59e0b',
          fillColor: '#fbbf24',
          fillOpacity: 0.95,
          weight: 2,
          bubblingMouseEvents: false
        }).addTo(losLayer);
        marker.bindTooltip(tooltip, { direction: 'top', opacity: 0.9 });
        marker.on('click', (ev) => {
          if (ev && ev.originalEvent) {
            ev.originalEvent.preventDefault();
            ev.originalEvent.stopPropagation();
          }
          const coords = `${lat.toFixed(5)}, ${lon.toFixed(5)}`;
          if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(coords).then(() => {
              setLosStatus(`LOS: Peak ${index} coords copied`);
            }).catch(() => {
              setLosStatus(`LOS: Peak ${index} ${coords}`);
            });
          } else {
            setLosStatus(`LOS: Peak ${index} ${coords}`);
          }
        });
        losPeakMarkers.push(marker);
      });
    }

    async function runLosCheckServer(a, b) {
      const params = new URLSearchParams({
        lat1: a.lat.toFixed(6),
        lon1: a.lng.toFixed(6),
        lat2: b.lat.toFixed(6),
        lon2: b.lng.toFixed(6)
      });
      const res = await fetch(`/los?${params.toString()}`);
      const data = await res.json();
      if (!data.ok) {
        setLosStatus(`LOS: ${data.error || 'failed'}`);
        if (losLine) {
          losLine.setStyle({ color: '#9ca3af', weight: 4, opacity: 0.8, dashArray: '6 10' });
        }
        clearLosProfile();
        clearLosPeaks();
        return false;
      }
      const blocked = data.blocked;
      let distance = '';
      if (data.distance_m != null) {
        const meters = Number(data.distance_m);
        if (!Number.isNaN(meters)) {
          distance = meters >= 1000
            ? `${(meters / 1000).toFixed(2)} km`
            : `${Math.round(meters)} m`;
        }
      }
      const obstruction = blocked ? `Blocked (+${data.max_obstruction_m}m)` : 'Clear';
      let statusText = `LOS: ${distance} • ${obstruction}`;
      if (losSuggestion) {
        losLayer.removeLayer(losSuggestion);
        losSuggestion = null;
      }
      renderLosPeaks(data.peaks);
      if (data.suggested) {
        const s = data.suggested;
        const label = s.clear ? 'Relay (Clear)' : 'Relay (Still Blocked)';
        const color = s.clear ? '#22c55e' : '#f59e0b';
        losSuggestion = L.circleMarker([s.lat, s.lon], {
          radius: 6,
          color,
          fillColor: color,
          fillOpacity: 0.9,
          weight: 2
        }).addTo(losLayer);
        losSuggestion.bindTooltip(`${label}<br/>${s.lat}, ${s.lon}`, { direction: 'top' });
        statusText += s.clear ? ' • Relay Suggested' : ' • Relay May Help (Still Blocked)';
      }
      setLosStatus(statusText);
      renderLosProfile(data.profile, blocked);
      if (losLine) {
        losLine.setStyle({
          color: blocked ? '#ef4444' : '#22c55e',
          weight: 5,
          opacity: 0.9,
          dashArray: blocked ? '4 10' : null
        });
      }
      return true;
    }

    function formatLastContact(tsSeconds) {
      if (!tsSeconds) return 'unknown';
      const dt = new Date(tsSeconds * 1000);
      return dt.toLocaleString(undefined, {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: 'numeric',
        minute: '2-digit',
        second: '2-digit',
        hour12: true
      });
    }

    function haversineMeters(lat1, lon1, lat2, lon2) {
      const R = 6371000;
      const toRad = (deg) => (deg * Math.PI) / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat / 2) ** 2 +
        Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
        Math.sin(dLon / 2) ** 2;
      return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function sampleLosPoints(lat1, lon1, lat2, lon2) {
      const distance = haversineMeters(lat1, lon1, lat2, lon2);
      if (distance <= 0) {
        return [
          { lat: lat1, lon: lon1, t: 0 },
          { lat: lat2, lon: lon2, t: 1 }
        ];
      }
      let samples = Math.floor(distance / Math.max(1, losSampleStepMeters)) + 1;
      samples = Math.max(losSampleMin, Math.min(losSampleMax, samples));
      if (samples < 2) samples = 2;
      const points = [];
      for (let i = 0; i < samples; i += 1) {
        const t = i / (samples - 1);
        const lat = lat1 + (lat2 - lat1) * t;
        const lon = lon1 + (lon2 - lon1) * t;
        points.push({ lat, lon, t });
      }
      return points;
    }

    async function fetchElevations(points) {
      if (!losElevationUrl) {
        return { ok: false, error: 'no_elevation_url' };
      }
      const results = new Array(points.length);
      const chunkSize = 100;
      for (let start = 0; start < points.length; start += chunkSize) {
        const chunk = points.slice(start, start + chunkSize);
        const locations = chunk.map(p => `${p.lat},${p.lon}`).join('|');
        const url = `${losElevationUrl}?locations=${encodeURIComponent(locations)}`;
        let payload;
        try {
          const res = await fetch(url);
          payload = await res.json();
        } catch (err) {
          return { ok: false, error: 'elevation_fetch_failed' };
        }
        if (payload.status && payload.status !== 'OK') {
          return { ok: false, error: `elevation_fetch_failed:${payload.status}` };
        }
        const elevs = payload.results || [];
        if (elevs.length !== chunk.length) {
          return { ok: false, error: 'elevation_fetch_failed:unexpected_length' };
        }
        elevs.forEach((entry, idx) => {
          results[start + idx] = Number(entry.elevation);
        });
      }
      if (results.some(val => val == null || Number.isNaN(val))) {
        return { ok: false, error: 'elevation_fetch_failed:missing' };
      }
      return { ok: true, elevations: results };
    }

    function losMaxObstruction(points, elevations, startIdx, endIdx) {
      if (endIdx <= startIdx + 1) return 0;
      const startT = points[startIdx].t;
      const endT = points[endIdx].t;
      if (endT <= startT) return 0;
      const startElev = elevations[startIdx];
      const endElev = elevations[endIdx];
      let maxObstruction = 0;
      for (let idx = startIdx + 1; idx < endIdx; idx += 1) {
        const frac = (points[idx].t - startT) / (endT - startT);
        const lineElev = startElev + (endElev - startElev) * frac;
        const clearance = elevations[idx] - lineElev;
        if (clearance > maxObstruction) maxObstruction = clearance;
      }
      return maxObstruction;
    }

    function findLosSuggestion(points, elevations) {
      if (points.length < 3) return null;
      let bestIdx = null;
      let bestScore = null;
      let bestClear = false;
      for (let idx = 1; idx < points.length - 1; idx += 1) {
        const obstA = losMaxObstruction(points, elevations, 0, idx);
        const obstB = losMaxObstruction(points, elevations, idx, points.length - 1);
        const score = Math.max(obstA, obstB);
        const clear = score <= 0;
        if (clear && !bestClear) {
          bestIdx = idx;
          bestScore = score;
          bestClear = true;
        } else if (clear && bestClear) {
          if (elevations[idx] > elevations[bestIdx]) {
            bestIdx = idx;
            bestScore = score;
          }
        } else if (!bestClear) {
          if (bestScore == null || score < bestScore) {
            bestIdx = idx;
            bestScore = score;
          }
        }
      }
      if (bestIdx == null) return null;
      return {
        lat: Number(points[bestIdx].lat.toFixed(6)),
        lon: Number(points[bestIdx].lon.toFixed(6)),
        elevation_m: Number(elevations[bestIdx].toFixed(2)),
        clear: bestClear,
        max_obstruction_m: bestScore != null ? Number(bestScore.toFixed(2)) : null
      };
    }

    function findLosPeaks(points, elevations, distanceMeters) {
      if (points.length < 3) return [];
      const peakIndices = [];
      for (let i = 1; i < elevations.length - 1; i += 1) {
        const elev = elevations[i];
        if (elev >= elevations[i - 1] && elev >= elevations[i + 1]) {
          peakIndices.push(i);
        }
      }
      if (peakIndices.length === 0) {
        let maxIdx = 1;
        for (let i = 2; i < elevations.length - 1; i += 1) {
          if (elevations[i] > elevations[maxIdx]) maxIdx = i;
        }
        peakIndices.push(maxIdx);
      }
      const limited = peakIndices
        .sort((a, b) => elevations[b] - elevations[a])
        .slice(0, losPeaksMax)
        .sort((a, b) => points[a].t - points[b].t);
      return limited.map((idx, i) => ({
        index: i + 1,
        lat: Number(points[idx].lat.toFixed(6)),
        lon: Number(points[idx].lon.toFixed(6)),
        elevation_m: Number(elevations[idx].toFixed(2)),
        distance_m: Number((distanceMeters * points[idx].t).toFixed(2))
      }));
    }

    function makePopup(d) {
      const lastContact = formatLastContact(d.ts);
      const deviceLabel = deviceShortId(d);
      const title = d.name
        ? `<span class="popup-title">${d.name}</span><span class="popup-id">${deviceLabel}</span>`
        : `<span class="popup-title popup-id">${deviceLabel}</span>`;
      const role = resolveRole(d);
      const roleLabel = role === 'unknown' ? '' : role.charAt(0).toUpperCase() + role.slice(1);
      return `
        ${title}
        <span class="small">
          ${roleLabel ? `Role: ${roleLabel}<br/>` : ``}
          Location: ${d.lat.toFixed(6)}, ${d.lon.toFixed(6)}<br/>
          Last Contact: ${lastContact}<br/>
          ${d.rssi != null ? `RSSI: ${d.rssi}<br/>` : ``}
          ${d.snr != null ? `SNR: ${d.snr}<br/>` : ``}
        </span>
      `;
    }

    function upsertDevice(d, trail) {
      const id = d.device_id;
      const latlng = [d.lat, d.lon];
      const role = resolveRole(d);
      const style = markerStyleForRole(role);
      deviceData.set(id, d);

      // marker
      if (!markers.has(id)) {
        const m = L.circleMarker(latlng, style).addTo(map);
        m.bindPopup(makePopup(d), {
          maxWidth: 260,
          maxHeight: 320,
          autoPan: true,
          keepInView: true,
          autoPanPadding: [18, 18]
        });
        m.on('click', (ev) => {
          const original = ev.originalEvent;
          if (original && original.shiftKey) {
            if (!losActive) {
              setLosActive(true);
            }
            handleLosPoint(m.getLatLng());
            m.closePopup();
            original.preventDefault();
            original.stopPropagation();
            L.DomEvent.stop(ev);
          }
        });
        markers.set(id, m);
        updateMarkerLabel(m, d);
      } else {
        const m = markers.get(id);
        m.setLatLng(latlng);
        m.setPopupContent(makePopup(d));
        if (m.setStyle) m.setStyle(style);
        updateMarkerLabel(m, d);
      }

      // trail polyline (skip companions)
      if (role !== 'companion' && Array.isArray(trail) && trail.length >= 2) {
        const points = trail.map(p => [p[0], p[1]]);
        if (!polylines.has(id)) {
          const pl = L.polyline(points, {
            color: '#38bdf8',
            weight: 3,
            opacity: 0.85,
            className: 'trail-animated'
          }).addTo(map);
          polylines.set(id, pl);
        } else {
          const pl = polylines.get(id);
          pl.setLatLngs(points);
          if (pl.setStyle) {
            pl.setStyle({ color: '#38bdf8', weight: 3, opacity: 0.85 });
          }
        }
      } else if (polylines.has(id) && role === 'companion') {
        map.removeLayer(polylines.get(id));
        polylines.delete(id);
      }

      setStats();
    }

    function removeDevices(ids) {
      ids.forEach(id => {
        if (markers.has(id)) {
          map.removeLayer(markers.get(id));
          markers.delete(id);
        }
        if (deviceData.has(id)) {
          deviceData.delete(id);
        }
        if (polylines.has(id)) {
          map.removeLayer(polylines.get(id));
          polylines.delete(id);
        }
      });
      setStats();
    }

    function removeRoutes(ids) {
      ids.forEach(id => {
        const entry = routeLines.get(id);
        if (!entry) return;
        if (entry.timeout) clearTimeout(entry.timeout);
        routeLayer.removeLayer(entry.line);
        routeLines.delete(id);
      });
      setStats();
    }

    function refreshHeatLayer() {
      const now = Date.now();
      const cutoff = now - HEAT_TTL_MS;
      const filtered = heatPoints.filter(p => p.ts >= cutoff);
      heatPoints.length = 0;
      heatPoints.push(...filtered);
      heatLayer.setLatLngs(heatPoints.map(p => [p.lat, p.lon, p.weight]));
    }

    function addHeatPoints(points, tsSeconds, payloadType) {
      if (!Array.isArray(points) || points.length < 1) return;
      if (Number(payloadType) === 4) return; // skip adverts for route-based heat
      const ts = (tsSeconds ? tsSeconds * 1000 : Date.now());
      points.forEach(p => {
        heatPoints.push({ lat: p[0], lon: p[1], ts, weight: 0.7 });
      });
      refreshHeatLayer();
    }

    function seedHeat(items) {
      if (!Array.isArray(items)) return;
      heatPoints.length = 0;
      items.forEach(item => {
        if (!Array.isArray(item) || item.length < 3) return;
        heatPoints.push({
          lat: item[0],
          lon: item[1],
          ts: item[2] * 1000,
          weight: item[3] != null ? item[3] : 0.7
        });
      });
      refreshHeatLayer();
    }

    function upsertRoute(r, skipHeat = false) {
      if (!r || !Array.isArray(r.points) || r.points.length < 2) return;
      const id = r.id || `route-${Date.now()}-${Math.random()}`;
      const points = r.points.map(p => [p[0], p[1]]);
      const routeMode = r.route_mode || 'path';
      const isFanout = routeMode === 'fanout';
      const payloadType = Number(r.payload_type);
      const isAdvert = payloadType === 4;
      const style = {
        color: isAdvert ? '#2ecc71' : (isFanout ? '#2b8cff' : '#ff7a1a'),
        weight: isFanout ? 4 : 5,
        opacity: isFanout ? 0.85 : 0.9,
        lineCap: 'butt',
        lineJoin: 'miter'
      };
      if (!isFanout) {
        style.dashArray = isAdvert ? '4 10' : '8 14';
      }

      let entry = routeLines.get(id);
      if (!entry) {
        const line = L.polyline(points, style).addTo(routeLayer);
        entry = { line, timeout: null };
        routeLines.set(id, entry);
      } else {
        entry.line.setLatLngs(points);
        entry.line.setStyle(style);
      }
      const lineEl = entry.line.getElement();
      if (lineEl) {
        lineEl.classList.add('route-animated');
      }

      if (entry.timeout) clearTimeout(entry.timeout);
      if (r.expires_at) {
        const ms = Math.max(1000, (r.expires_at * 1000) - Date.now());
        entry.timeout = setTimeout(() => removeRoutes([id]), ms);
      }

      if (!skipHeat) {
        addHeatPoints(points, r.ts, r.payload_type);
      }
      setStats();
    }

    async function initialSnapshot() {
      try {
        const res = await fetch('/snapshot');
        const snap = await res.json();
        if (snap.devices) {
          for (const [id, d] of Object.entries(snap.devices)) {
            const trail = snap.trails ? snap.trails[id] : null;
            upsertDevice(d, trail);
          }
        }
        if (Array.isArray(snap.heat)) {
          seedHeat(snap.heat);
        }
        if (Array.isArray(snap.routes)) {
          snap.routes.forEach(r => upsertRoute(r, true));
        }
      } catch (e) {
        console.warn("snapshot failed", e);
      }
    }

    function connectWS() {
      const proto = location.protocol === 'https:' ? 'wss' : 'ws';
      const ws = new WebSocket(`${proto}://${location.host}/ws`);

      ws.onopen = () => console.log("ws connected");
      ws.onclose = () => {
        console.log("ws disconnected, retrying...");
        setTimeout(connectWS, 1500);
      };

      ws.onmessage = (ev) => {
        const msg = JSON.parse(ev.data);

        if (msg.type === "snapshot") {
          // same shape as /snapshot
          for (const [id, d] of Object.entries(msg.devices || {})) {
            const trail = msg.trails ? msg.trails[id] : null;
            upsertDevice(d, trail);
          }
          if (Array.isArray(msg.heat)) {
            seedHeat(msg.heat);
          }
          if (Array.isArray(msg.routes)) {
            msg.routes.forEach(r => upsertRoute(r, true));
          }
          return;
        }

        if (msg.type === "update") {
          upsertDevice(msg.device, msg.trail);
          return;
        }

        if (msg.type === "route") {
          upsertRoute(msg.route);
          return;
        }

        if (msg.type === "route_remove") {
          removeRoutes(msg.route_ids || []);
          return;
        }

        if (msg.type === "stale") {
          removeDevices(msg.device_ids || []);
          return;
        }
      };
    }

    async function runLosCheck() {
      if (losPoints.length < 2) return;
      const [a, b] = losPoints;
      setLosStatus('LOS: calculating...');
      try {
        const distanceMeters = haversineMeters(a.lat, a.lng, b.lat, b.lng);
        if (distanceMeters <= 0) {
          setLosStatus('LOS: invalid distance');
          return;
        }
        const points = sampleLosPoints(a.lat, a.lng, b.lat, b.lng);
        const elevationResult = await fetchElevations(points);
        if (!elevationResult.ok) {
          const fallbackOk = await runLosCheckServer(a, b);
          if (fallbackOk) return;
          setLosStatus(`LOS: ${elevationResult.error || 'failed'}`);
          if (losLine) {
            losLine.setStyle({ color: '#9ca3af', weight: 4, opacity: 0.8, dashArray: '6 10' });
          }
          clearLosProfile();
          clearLosPeaks();
          return;
        }
        const elevations = elevationResult.elevations;
        const startElev = elevations[0];
        const endElev = elevations[elevations.length - 1];
        const maxObstruction = losMaxObstruction(points, elevations, 0, elevations.length - 1);
        const blocked = maxObstruction > 0;
        const suggestion = blocked ? findLosSuggestion(points, elevations) : null;
        const profile = points.map((p, idx) => {
          const lineElev = startElev + (endElev - startElev) * p.t;
          return [
            Number((distanceMeters * p.t).toFixed(2)),
            Number(elevations[idx].toFixed(2)),
            Number(lineElev.toFixed(2))
          ];
        });
        const peaks = findLosPeaks(points, elevations, distanceMeters);
        let distance = '';
        if (!Number.isNaN(distanceMeters)) {
          distance = distanceMeters >= 1000
            ? `${(distanceMeters / 1000).toFixed(2)} km`
            : `${Math.round(distanceMeters)} m`;
        }
        const obstruction = blocked ? `Blocked (+${maxObstruction.toFixed(2)}m)` : 'Clear';
        let statusText = `LOS: ${distance} • ${obstruction}`;
        if (losSuggestion) {
          losLayer.removeLayer(losSuggestion);
          losSuggestion = null;
        }
        renderLosPeaks(peaks);
        if (suggestion) {
          const s = suggestion;
          const label = s.clear ? 'Relay (Clear)' : 'Relay (Still Blocked)';
          const color = s.clear ? '#22c55e' : '#f59e0b';
          losSuggestion = L.circleMarker([s.lat, s.lon], {
            radius: 6,
            color,
            fillColor: color,
            fillOpacity: 0.9,
            weight: 2
          }).addTo(losLayer);
          losSuggestion.bindTooltip(`${label}<br/>${s.lat}, ${s.lon}`, { direction: 'top' });
          statusText += s.clear ? ' • Relay Suggested' : ' • Relay May Help (Still Blocked)';
        }
        setLosStatus(statusText);
        renderLosProfile(profile, blocked);
        if (losLine) {
          losLine.setStyle({
            color: blocked ? '#ef4444' : '#22c55e',
            weight: 5,
            opacity: 0.9,
            dashArray: blocked ? '4 10' : null
          });
        }
      } catch (err) {
        console.warn('los failed', err);
        setLosStatus('LOS: error');
        clearLosProfile();
        clearLosPeaks();
      }
    }

    initialSnapshot();
    connectWS();
    setStats();
    setInterval(refreshHeatLayer, 15000);

    const legendToggle = document.getElementById('legend-toggle');
    const hud = document.querySelector('.hud');
    if (legendToggle && hud) {
      const storedLegend = localStorage.getItem('meshmapLegendCollapsed');
      if (storedLegend === 'true') {
        hud.classList.add('legend-collapsed');
        legendToggle.textContent = 'Show legend';
      }
      legendToggle.addEventListener('click', () => {
        const collapsed = hud.classList.toggle('legend-collapsed');
        legendToggle.textContent = collapsed ? 'Show legend' : 'Hide legend';
        localStorage.setItem('meshmapLegendCollapsed', collapsed ? 'true' : 'false');
      });
    }

    const mapToggle = document.getElementById('map-toggle');
    const topoToggle = document.getElementById('topo-toggle');
    function setBaseLayer(name) {
      if (map.hasLayer(lightTiles)) map.removeLayer(lightTiles);
      if (map.hasLayer(darkTiles)) map.removeLayer(darkTiles);
      if (map.hasLayer(topoTiles)) map.removeLayer(topoTiles);
      if (name === 'dark') {
        map.addLayer(darkTiles);
      } else if (name === 'topo') {
        map.addLayer(topoTiles);
      } else {
        map.addLayer(lightTiles);
      }
      baseLayer = name;
      localStorage.setItem('meshmapBaseLayer', baseLayer);
      if (mapToggle) {
        mapToggle.textContent = baseLayer === 'dark' ? 'Light map' : 'Dark map';
      }
      if (topoToggle) {
        topoToggle.textContent = baseLayer === 'topo' ? 'Standard map' : 'Topo map';
      }
    }

    if (mapToggle) {
      mapToggle.addEventListener('click', () => {
        setBaseLayer(baseLayer === 'dark' ? 'light' : 'dark');
      });
    }
    if (topoToggle) {
      topoToggle.addEventListener('click', () => {
        setBaseLayer(baseLayer === 'topo' ? 'light' : 'topo');
      });
    }
    setBaseLayer(baseLayer);

    const labelsToggle = document.getElementById('labels-toggle');
    if (labelsToggle) {
      labelsToggle.addEventListener('click', () => {
        setLabelsActive(!showLabels);
      });
    }
    setLabelsActive(showLabels);

    if (searchInput) {
      searchInput.addEventListener('input', (ev) => {
        renderSearchResults(ev.target.value);
      });
      searchInput.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter' && searchMatches.length > 0) {
          ev.preventDefault();
          focusDevice(searchMatches[0].id);
        }
      });
    }
    document.addEventListener('click', (ev) => {
      if (!searchResults || !searchInput) return;
      if (searchResults.contains(ev.target) || searchInput.contains(ev.target)) return;
      searchResults.hidden = true;
      searchResults.innerHTML = '';
    });

    if (losProfileSvg) {
      losProfileSvg.addEventListener('mousemove', updateLosProfileHover);
      losProfileSvg.addEventListener('mouseleave', clearLosProfileHover);
    }

    const losToggle = document.getElementById('los-toggle');
    if (losToggle) {
      losToggle.addEventListener('click', () => {
        setLosActive(!losActive);
      });
    }

    function handleLosPoint(latlng) {
      if (losPoints.length >= 2) {
        clearLos();
      }
      losPoints.push(latlng);
      L.circleMarker(latlng, {
        radius: 5,
        color: '#fbbf24',
        fillColor: '#fbbf24',
        fillOpacity: 0.9,
        weight: 2
      }).addTo(losLayer);

      if (losPoints.length === 1) {
        setLosStatus('LOS: select second point');
        return;
      }
      if (losPoints.length === 2) {
        losLine = L.polyline([losPoints[0], losPoints[1]], {
          color: '#9ca3af',
          weight: 4,
          opacity: 0.8,
          dashArray: '6 10'
        }).addTo(losLayer);
        losLine.on('mousemove', (ev) => {
          if (ev && ev.latlng) {
            updateLosProfileFromMap(ev.latlng);
          }
        });
        losLine.on('mouseout', clearLosProfileHover);
        runLosCheck();
      }
    }

    map.on('click', (ev) => {
      if (!losActive) return;
      handleLosPoint(ev.latlng);
    });
  </script>
</body>
</html>
